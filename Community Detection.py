# -*- coding: utf-8 -*-
"""Assignment3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WOSCpX7Mf2klsDJ08zi35VPvE1dsd9bu
"""

import numpy as np
import pandas as pd
import gc
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import math


def import_facebook_data(path):
    data_fb=pd.read_csv(path,delimiter=" ")
    return data_fb

def import_bitcoin_data(path):
    data_btc=pd.read_csv(path)
    return data_btc

def spectralDecomp_OneIter(nodes_connectivity_list_fb,nodes,n):
  gc.collect() 
  flag=0
  nodes=nodes
  adj_mat_fb = np.zeros((nodes, nodes))
  unoccupied=[]
  for i in range(nodes):
    if i not in list(set(list(nodes_connectivity_list_fb.iloc[0:,0]))) and i not in  list(set(list(nodes_connectivity_list_fb.iloc[0:,1]))):
      if i not in unoccupied:
        unoccupied.append(i)
  adj_mat_dict={}
  fielder_vec_fb=np.array([0 for _ in range(nodes)])
  graph_partition_fb=np.array([[i,0] for i in range(nodes)])
  for i in range(n):
      a=int(nodes_connectivity_list_fb.iloc[i][0])
      b=int(nodes_connectivity_list_fb.iloc[i][-1])
      if a>=nodes:
          if a not in adj_mat_dict.values():
            m=unoccupied.pop(0)
            adj_mat_dict[m]=a
            a=m

          else:
            a=[key for key, val in adj_mat_dict.items() if val == a][0]

      if b>=nodes:
          if b not in adj_mat_dict.values():
            m=unoccupied.pop(0)
            adj_mat_dict[m]=b
            b=m  
          else:
            b=[key for key, val in adj_mat_dict.items() if val == b][0]
        
      adj_mat_fb[a][b]=1
      adj_mat_fb[b][a]=1

  D_matrix=np.diag(np.sum(adj_mat_fb,axis=1))
        
  L_matrix=D_matrix-adj_mat_fb
  eigenvalues, eigenvectors = np.linalg.eig(L_matrix)

  eigendict={}
  for i in range(len(eigenvalues)):
      eigendict[eigenvalues[i]]=eigenvectors[i]

  sorted_eigen_dict = dict(sorted(eigendict.items(), key=lambda x: x[0]))

  for k in sorted_eigen_dict.keys(): 
    if k==0.0:
      continue
    else :
      fielder_vec_fb=sorted_eigen_dict[k]
      break

  community_1=[]
  community_2=[]
  community_ids=[]

  for i in range(len(fielder_vec_fb)):
    if(np.isnan(math.copysign(1, fielder_vec_fb[i]))):
      sign=1
    else:
      sign = math.copysign(1, fielder_vec_fb[i])

    #print(sign)
    if sign>0:
      if i in adj_mat_dict.values():
        keys = [key for key, val in adj_mat_dict.items() if val == i]
        community_1.append(keys[0])
      else:
        community_1.append(i)
    else:
      if i in adj_mat_dict.values():
        keys = [key for key, val in adj_mat_dict.items() if val == i]
        community_2.append(keys[0])
      else:
        community_2.append(i) 

  community_1.sort()
  community_2.sort()
  if(len(community_1)!=0) and (len(community_2)!=0):
    community_ids.append(community_1[0])
    community_ids.append(community_2[0])

    for j in range(nodes):
     if graph_partition_fb[j][0] in community_1:
      graph_partition_fb[j][-1]=community_ids[0]
     else:
      graph_partition_fb[j][-1]=community_ids[1]

  elif len(community_1)==0 and len(community_2)==0:
     flag=1
  
  elif len(community_1)==0:
     community_ids.append(community_2[0])
     for j in range(nodes):
      graph_partition_fb[j][-1]=community_ids[0]
      
  else:
     community_ids.append(community_1[0])
     for j in range(nodes):
      graph_partition_fb[j][-1]=community_ids[0]
  
  return fielder_vec_fb,adj_mat_fb,graph_partition_fb,flag

def spectralDecomp_OneIter_btc(nodes_connectivity_list_fb,nodes,n):
  gc.collect() 
  flag=0
  nodes=nodes
  adj_mat_fb = np.zeros((nodes, nodes))
  unoccupied=[]
  for i in range(nodes):
    if i not in list(set(list(nodes_connectivity_list_fb.iloc[0:,0]))) and i not in  list(set(list(nodes_connectivity_list_fb.iloc[0:,1]))):
      if i not in unoccupied:
        unoccupied.append(i)
  adj_mat_dict={}
  fielder_vec_fb=np.array([0 for _ in range(nodes)])
  graph_partition_fb=np.array([[i,0] for i in range(nodes)])
  for i in range(n):
      a=int(nodes_connectivity_list_fb.iloc[i][0])
      b=int(nodes_connectivity_list_fb.iloc[i][1])
      if a>=nodes:
          if a not in adj_mat_dict.values():
            m=unoccupied.pop(0)
            adj_mat_dict[m]=a
            a=m

          else:
            a=[key for key, val in adj_mat_dict.items() if val == a][0]

      if b>=nodes:
          if b not in adj_mat_dict.values():
            m=unoccupied.pop(0)
            adj_mat_dict[m]=b
            b=m  
          else:
            b=[key for key, val in adj_mat_dict.items() if val == b][0]
        
      adj_mat_fb[a][b]=1
      adj_mat_fb[b][a]=1

  D_matrix=np.diag(np.sum(adj_mat_fb,axis=1))
        
  L_matrix=D_matrix-adj_mat_fb
  eigenvalues, eigenvectors = np.linalg.eig(L_matrix)

  eigendict={}
  for i in range(len(eigenvalues)):
      eigendict[eigenvalues[i]]=eigenvectors[i]

  sorted_eigen_dict = dict(sorted(eigendict.items(), key=lambda x: x[0]))

  for k in sorted_eigen_dict.keys(): 
    if k==0.0:
      continue
    else :
      fielder_vec_fb=sorted_eigen_dict[k]
      break

  community_1=[]
  community_2=[]
  community_ids=[]

  for i in range(len(fielder_vec_fb)):
    if(np.isnan(math.copysign(1, fielder_vec_fb[i]))):
      sign=1
    else:
      sign = math.copysign(1, fielder_vec_fb[i])

    #print(sign)
    if sign>0:
      if i in adj_mat_dict.values():
        keys = [key for key, val in adj_mat_dict.items() if val == i]
        community_1.append(keys[0])
      else:
        community_1.append(i)
    else:
      if i in adj_mat_dict.values():
        keys = [key for key, val in adj_mat_dict.items() if val == i]
        community_2.append(keys[0])
      else:
        community_2.append(i) 

  community_1.sort()
  community_2.sort()
  if(len(community_1)!=0) and (len(community_2)!=0):
    community_ids.append(community_1[0])
    community_ids.append(community_2[0])

    for j in range(nodes):
     if graph_partition_fb[j][0] in community_1:
      graph_partition_fb[j][-1]=community_ids[0]
     else:
      graph_partition_fb[j][-1]=community_ids[1]

  elif len(community_1)==0 and len(community_2)==0:
     flag=1
  
  elif len(community_1)==0:
     community_ids.append(community_2[0])
     for j in range(nodes):
      graph_partition_fb[j][-1]=community_ids[0]
      
  else:
     community_ids.append(community_1[0])
     for j in range(nodes):
      graph_partition_fb[j][-1]=community_ids[0]
  
  return fielder_vec_fb,adj_mat_fb,graph_partition_fb,flag

if __name__ == "__main__":

    nodes_connectivity_list_fb_ = import_facebook_data("/Users/akshsaxe/Desktop/IISC_/IISc Sem 3/data/facebook_combined.txt")
    
    no_of_nodes=4039 # As given in the facebook dataset
    n=nodes_connectivity_list_fb.shape[0]
    fielder_vec, adj_mat, graph_partition,flag = spectralDecomp_OneIter(nodes_connectivity_list_fb,no_of_nodes,n)
    
    
    sorted_fielder_vec=np.sort(fielder_vec)
    nodes=np.arange(0,4039)
    plt.title("Fielder Vector")
    plt.scatter(nodes,sorted_fielder_vec)
    plt.yscale('symlog', linthresh=1e-20)
    plt.ylim(bottom=-1e-16, top=1e-16)
    plt.show()
    plt.savefig("Fielder_vectorQ1.pdf")

    plt.title("Fielder Vector Graph Version2")
    plt.scatter(nodes,sorted_fielder_vec)
    plt.yscale('log')
    plt.show()
    plt.savefig("Fielder_vector_2_Q1.pdf")
    
    fig, ax = plt.subplots()
    ax.imshow(adj_mat, cmap='binary', interpolation='nearest')
    cbar = plt.colorbar(ax.imshow(adj_mat, cmap='binary'))
    ax.set_xlabel('Nodes')
    ax.set_ylabel('Nodes')
    ax.set_title('Adjacency Matrix')
    plt.show()
    plt.savefig("Adjacency_Q1.pdf")
    
    G2 = nx.from_edgelist(graph_partition)
    G2.edges(data=True)
    plt.figure(figsize=(8, 6))  # Set the figure size
    pos = nx.spring_layout(G2)  # Layout the nodes using the spring layout algorithm
    nx.draw(G2, pos, with_labels=False)
    plt.title("Graph Partition")
    plt.show()
    plt.savefig("Partition_graph_Q1.pdf")
    
    graph_tracker = []
    graph_tracker.append(np.zeros((5881, 2)))
    graph_tracker.append(np.array(graph_partition))
    while not(np.array_equal(graph_tracker[-2], graph_tracker[-1])): # loop algorithm is not able to form more communities
      dp=pd.DataFrame(graph_tracker[-1])
      community=np.array(list(set(dp.iloc[0:,1])))
      i=0
      comm_len=len(community)
      while i<comm_len:
        nodes_conn=nodes_connectivity_list_btc.copy()
        for j in range(len(dp.iloc[0:,0])):
          if np.array((dp.iloc[0:,1])[j])!=community[i]:
            nodes_conn.drop(nodes_conn[nodes_conn.iloc[0:,0] == dp.iloc[0:,0][j]].index, inplace=True)
        nodes=len((set(list(nodes_conn.iloc[0:,0]))| set(list(nodes_conn.iloc[0:,1]))))
        n=nodes_conn.shape[0]
        fielder_vec_2,adj_mat_2,graph_partition_2,flag=spectralDecomp_OneIter_btc(nodes_conn,nodes,n)
        if flag!=1:
          graph_partition_2=np.array(graph_partition_2)
          for k in range(graph_partition_2.shape[0]):
            graph_partition[graph_partition_2[k][0]][1] = graph_partition_2[k][1]
          dp=pd.DataFrame(graph_partition)
          community2=np.array(list(set(dp.iloc[0:,1])))
          if np.all(np.in1d(community2, community)):
            i+=1
          else:
            elements_to_add = community2[~np.isin(community2, community)]
            community = np.concatenate((community, elements_to_add))
            comm_len=len(community)
            i+=1
            
        else:
          i+=1
          continue
      graph_tracker.append(np.array(graph_partition))

    G2 = nx.from_edgelist(graph_partition)
    G2.edges(data=True)
    plt.figure(figsize=(8, 6))  # Set the figure size
    pos = nx.spring_layout(G2)  # Layout the nodes using the spring layout algorithm
    nx.draw(G2, pos, with_labels=False)
    plt.title("Graph Partition")
    plt.show()`
  
    

    ############ Answer qn 1-4 for bitcoin data #################################################
    # Import soc-sign-bitcoinotc.csv
    nodes_connectivity_list_btc = import_bitcoin_data("/Users/akshsaxe/Desktop/IISC_/IISc Sem 3/data/soc-sign-bitcoinotc .csv")
    nodes_connectivity_list_btc.columns=[0,1,2,3]
    nodes_connectivity_list_btc= nodes_connectivity_list_btc.iloc[:, :2]
    nodes_connectivity_list_btc=nodes_connectivity_list_btc.drop_duplicates()


    no_of_nodes=5881 # As given in the btc dataset
    n=nodes_connectivity_list_btc.shape[0]
    fielder_vec, adj_mat, graph_partition,flag = spectralDecomp_OneIter_btc(nodes_connectivity_list_btc,no_of_nodes,n)
    
    
    sorted_fielder_vec=np.sort(fielder_vec)
    nodes=np.arange(0,5881)
    plt.title("Fielder Vector")
    plt.scatter(nodes,sorted_fielder_vec)
    plt.yscale('symlog', linthresh=1e-20)
    plt.ylim(bottom=-1e-16, top=1e-16)
    plt.show()
    plt.savefig("Fielder_vectorQ1.pdf")

    plt.title("Fielder Vector Graph Version2")
    plt.scatter(nodes,sorted_fielder_vec)
    plt.yscale('log')
    plt.show()
    plt.savefig("Fielder_vector_2_Q1.pdf")
    
    fig, ax = plt.subplots()
    im = ax.imshow(adj_mat, cmap='binary', interpolation='nearest')

    # Add colorbar
    cbar = fig.colorbar(im)

    ax.set_xlabel('Nodes')
    ax.set_ylabel('Nodes')
    ax.set_title('Adjacency Matrix')

    plt.tight_layout()
    plt.show()
    fig.savefig("Adjacency_Q1.pdf")

    
    G2 = nx.from_edgelist(graph_partition)
    G2.edges(data=True)
    plt.figure(figsize=(8, 6))  # Set the figure size
    pos = nx.spring_layout(G2)  # Layout the nodes using the spring layout algorithm
    nx.draw(G2, pos, with_labels=False)
    plt.title("Graph Partition")
    plt.show()
    plt.savefig("Partition_graph_Q1.pdf")

    graph_tracker = []
    graph_tracker.append(np.zeros((5881, 2)))
    graph_tracker.append(np.array(graph_partition))
    while not(np.array_equal(graph_tracker[-2], graph_tracker[-1])): # loop algorithm is not able to form more communities
      dp=pd.DataFrame(graph_tracker[-1])
      community=np.array(list(set(dp.iloc[0:,1])))
      i=0
      comm_len=len(community)
      while i<comm_len:
        nodes_conn=nodes_connectivity_list_btc.copy()
        for j in range(len(dp.iloc[0:,0])):
          if np.array((dp.iloc[0:,1])[j])!=community[i]:
            nodes_conn.drop(nodes_conn[nodes_conn.iloc[0:,0] == dp.iloc[0:,0][j]].index, inplace=True)
        nodes=len((set(list(nodes_conn.iloc[0:,0]))| set(list(nodes_conn.iloc[0:,1]))))
        n=nodes_conn.shape[0]
        fielder_vec_2,adj_mat_2,graph_partition_2,flag=spectralDecomp_OneIter_btc(nodes_conn,nodes,n)
        if flag!=1:
          graph_partition_2=np.array(graph_partition_2)
          for k in range(graph_partition_2.shape[0]):
            graph_partition[graph_partition_2[k][0]][1] = graph_partition_2[k][1]
          dp=pd.DataFrame(graph_partition)
          community2=np.array(list(set(dp.iloc[0:,1])))
          if np.all(np.in1d(community2, community)):
            i+=1
          else:
            elements_to_add = community2[~np.isin(community2, community)]
            community = np.concatenate((community, elements_to_add))
            comm_len=len(community)
            i+=1
            
        else:
          i+=1
          continue
      
      graph_tracker.append(np.array(graph_partition))

    G2 = nx.from_edgelist(graph_partition)
    G2.edges(data=True)
    plt.figure(figsize=(8, 6))  # Set the figure size
    pos = nx.spring_layout(G2)  # Layout the nodes using the spring layout algorithm
    nx.draw(G2, pos, with_labels=False)
    plt.title("Graph Partition")
    plt.show()

#Louvain Algo, implemeneted seperately
    # Load the Facebook data.
    data = np.loadtxt("/content/facebook_combined.txt", dtype=int)

    # Create a graph from the data.
    G = nx.Graph()
    for edge in data:
        G.add_edge(edge[0], edge[1])

    # Initialize communities with each node in its own community.
    communities = {node: [node] for node in G.nodes()}

    # Iterate for one iteration.
    for _ in range(1):
        # Find the best community for each node.
        new_communities = {}
        for node in G.nodes():
            best_community = None
            best_modularity = -float("inf")
            for community in communities.values():
                within_community_edges = len([edge for edge in G.edges(node) if edge[0] in community and edge[1] in community])
                between_community_edges = len([edge for edge in G.edges(node) if edge[0] not in community or edge[1] not in community])
                total_edges = len(G.edges())
                new_modularity = (within_community_edges - (total_edges / 2)) / total_edges
                if new_modularity > best_modularity:
                    best_community = community
                    best_modularity = new_modularity
            new_communities[node] = best_community

        # Update the communities.
        communities = new_communities

    # Print the graph partition.
    graph_partition = np.array([node for node, community in communities.items()], dtype=int)
    print(graph_partition)

    
  
